"""
Malware and suspicious code detection scanner
"""
import re
import os
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime
from app.core.config import settings
from app.models.findings import Finding, FindingType, RiskLevel

class MalwareScanner:
    """Handles detection of malicious and suspicious code patterns"""
    
    def __init__(self):
        self.suspicious_patterns = self._compile_patterns()
        self.wordpress_specific_patterns = self._compile_wp_patterns()
    
    def _compile_patterns(self) -> List[Dict[str, Any]]:
        """Compile regex patterns for suspicious code detection"""
        patterns = []
        
        # PHP execution functions
        php_exec_patterns = [
            (r"eval\s*\(", "eval() function call", RiskLevel.HIGH),
            (r"base64_decode\s*\(", "base64_decode() function", RiskLevel.MEDIUM),
            (r"system\s*\(", "system() command execution", RiskLevel.HIGH),
            (r"shell_exec\s*\(", "shell_exec() command execution", RiskLevel.HIGH),
            (r"exec\s*\(", "exec() command execution", RiskLevel.HIGH),
            (r"passthru\s*\(", "passthru() command execution", RiskLevel.HIGH),
            (r"popen\s*\(", "popen() process execution", RiskLevel.HIGH),
            (r"proc_open\s*\(", "proc_open() process execution", RiskLevel.HIGH),
            (r"assert\s*\(", "assert() function (potential code execution)", RiskLevel.MEDIUM),
            (r"create_function\s*\(", "create_function() (deprecated, risky)", RiskLevel.HIGH),
        ]
        
        # File operations
        file_patterns = [
            (r"file_get_contents\s*\([^)]*http", "Remote file inclusion", RiskLevel.HIGH),
            (r"file_put_contents\s*\(", "File write operation", RiskLevel.MEDIUM),
            (r"fopen\s*\([^)]*['\"]w", "File write operation", RiskLevel.MEDIUM),
            (r"fwrite\s*\(", "File write operation", RiskLevel.MEDIUM),
            (r"fputs\s*\(", "File write operation", RiskLevel.MEDIUM),
        ]
        
        # Network operations
        network_patterns = [
            (r"curl_exec\s*\(", "CURL execution", RiskLevel.MEDIUM),
            (r"fsockopen\s*\(", "Socket connection", RiskLevel.MEDIUM),
            (r"socket_create\s*\(", "Socket creation", RiskLevel.MEDIUM),
        ]
        
        # PHP input sanitization issues
        input_patterns = [
            (r"\$_POST\[[^]]*\]\s*(?!.*(?:sanitize|escape|filter))", "Unsanitized POST input", RiskLevel.MEDIUM),
            (r"\$_GET\[[^]]*\]\s*(?!.*(?:sanitize|escape|filter))", "Unsanitized GET input", RiskLevel.MEDIUM),
            (r"\$_REQUEST\[[^]]*\]\s*(?!.*(?:sanitize|escape|filter))", "Unsanitized REQUEST input", RiskLevel.MEDIUM),
            (r"\$_COOKIE\[[^]]*\]\s*(?!.*(?:sanitize|escape|filter))", "Unsanitized COOKIE input", RiskLevel.MEDIUM),
        ]
        
        # Obfuscation patterns
        obfuscation_patterns = [
            (r"chr\s*\(\s*\d+\s*\)", "Character obfuscation", RiskLevel.MEDIUM),
            (r"hex2bin\s*\(", "Hexadecimal decoding", RiskLevel.MEDIUM),
            (r"gzinflate\s*\(", "Compressed code execution", RiskLevel.HIGH),
            (r"gzuncompress\s*\(", "Compressed code execution", RiskLevel.HIGH),
            (r"str_rot13\s*\(", "ROT13 obfuscation", RiskLevel.MEDIUM),
        ]
        
        # JavaScript suspicious patterns
        js_patterns = [
            (r"unescape\s*\(", "JavaScript unescape (obfuscation)", RiskLevel.MEDIUM),
            (r"String\.fromCharCode\s*\(", "JavaScript character encoding", RiskLevel.MEDIUM),
            (r"atob\s*\(", "Base64 decode in JavaScript", RiskLevel.MEDIUM),
            (r"document\.write\s*\(", "Dynamic content injection", RiskLevel.LOW),
            (r"innerHTML\s*=", "Dynamic HTML injection", RiskLevel.LOW),
        ]
        
        # SQL injection patterns
        sql_patterns = [
            (r"UNION\s+SELECT", "SQL injection attempt", RiskLevel.HIGH),
            (r"DROP\s+TABLE", "SQL table drop", RiskLevel.CRITICAL),
            (r"DELETE\s+FROM", "SQL delete operation", RiskLevel.HIGH),
        ]
        
        # Compile all patterns
        all_patterns = php_exec_patterns + file_patterns + network_patterns + input_patterns + obfuscation_patterns + js_patterns + sql_patterns
        
        for pattern, description, risk_level in all_patterns:
            patterns.append({
                "regex": re.compile(pattern, re.IGNORECASE),
                "pattern": pattern,
                "description": description,
                "risk_level": risk_level
            })
        
        return patterns
    
    def _compile_wp_patterns(self) -> List[Dict[str, Any]]:
        """Compile WordPress-specific suspicious patterns"""
        wp_patterns = [
            (r"wp_remote_get\s*\([^)]*\$", "Dynamic WordPress HTTP request", RiskLevel.MEDIUM),
            (r"add_action\s*\([^)]*eval", "WordPress hook with eval", RiskLevel.HIGH),
            (r"add_filter\s*\([^)]*eval", "WordPress filter with eval", RiskLevel.HIGH),
            (r"wp_enqueue_script\s*\([^)]*\$", "Dynamic script enqueuing", RiskLevel.MEDIUM),
            (r"current_user_can\s*\(\s*['\"]administrator['\"]", "Admin privilege check bypass", RiskLevel.HIGH),
        ]
        
        patterns = []
        for pattern, description, risk_level in wp_patterns:
            patterns.append({
                "regex": re.compile(pattern, re.IGNORECASE),
                "pattern": pattern,
                "description": description,
                "risk_level": risk_level
            })
        
        return patterns
    
    async def scan_file(self, file_path: Path) -> List[Finding]:
        """
        Scan a single file for malicious patterns
        
        Args:
            file_path: Path to the file to scan
            
        Returns:
            List of findings
        """
        findings = []
        
        if not file_path.exists() or file_path.is_dir():
            return findings
        
        # Only scan text files
        if file_path.suffix.lower() not in ['.php', '.js', '.html', '.htm', '.css', '.txt']:
            return findings
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')
        except Exception as e:
            # Can't read file, skip
            return findings
        
        # Scan with all patterns
        all_patterns = self.suspicious_patterns + self.wordpress_specific_patterns
        
        for pattern_info in all_patterns:
            matches = pattern_info["regex"].finditer(content)
            
            for match in matches:
                # Find line number
                line_num = content[:match.start()].count('\n') + 1
                
                # Get surrounding context
                start_line = max(0, line_num - 3)
                end_line = min(len(lines), line_num + 2)
                context_lines = lines[start_line:end_line]
                code_snippet = '\n'.join(context_lines)
                
                finding = Finding(
                    file_path=str(file_path),
                    finding_type=FindingType.SUSPICIOUS_CODE,
                    risk_level=pattern_info["risk_level"],
                    description=f"{pattern_info['description']} found in {file_path.name}",
                    line_number=line_num,
                    code_snippet=code_snippet,
                    pattern_matched=pattern_info["pattern"],
                    confidence=0.8  # Base confidence level
                )
                
                findings.append(finding)
        
        return findings
    
    async def scan_directory(self, scan_dir: Path) -> List[Finding]:
        """
        Scan entire directory for malicious patterns
        
        Args:
            scan_dir: Directory to scan recursively
            
        Returns:
            List of all findings
        """
        findings = []
        
        for root, dirs, files in os.walk(scan_dir):
            # Skip certain directories
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', '.git']]
            
            for file in files:
                file_path = Path(root) / file
                file_findings = await self.scan_file(file_path)
                findings.extend(file_findings)
        
        return findings
    
    def detect_wordpress_info(self, scan_dir: Path) -> Dict[str, Any]:
        """
        Extract WordPress version and installed plugins/themes
        
        Args:
            scan_dir: WordPress installation directory
            
        Returns:
            Dictionary with WordPress information
        """
        wp_info = {
            "version": None,
            "plugins": [],
            "themes": []
        }
        
        # Try to get WordPress version
        version_file = scan_dir / "wp-includes" / "version.php"
        if version_file.exists():
            try:
                with open(version_file, 'r') as f:
                    content = f.read()
                    version_match = re.search(r"\$wp_version\s*=\s*['\"]([^'\"]+)['\"]", content)
                    if version_match:
                        wp_info["version"] = version_match.group(1)
            except:
                pass
        
        # Get installed plugins
        plugins_dir = scan_dir / "wp-content" / "plugins"
        if plugins_dir.exists():
            for plugin_dir in plugins_dir.iterdir():
                if plugin_dir.is_dir() and not plugin_dir.name.startswith('.'):
                    wp_info["plugins"].append(plugin_dir.name)
        
        # Get installed themes
        themes_dir = scan_dir / "wp-content" / "themes"
        if themes_dir.exists():
            for theme_dir in themes_dir.iterdir():
                if theme_dir.is_dir() and not theme_dir.name.startswith('.'):
                    wp_info["themes"].append(theme_dir.name)
        
        return wp_info
    
    async def get_malware_summary(self, findings: List[Finding]) -> Dict[str, Any]:
        """Generate summary of malware scan results"""
        summary = {
            "total_suspicious_files": len(set(f.file_path for f in findings)),
            "total_patterns_found": len(findings),
            "risk_breakdown": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0
            },
            "pattern_breakdown": {}
        }
        
        for finding in findings:
            # Count by risk level
            summary["risk_breakdown"][finding.risk_level.value] += 1
            
            # Count by pattern type
            pattern = finding.pattern_matched or "unknown"
            summary["pattern_breakdown"][pattern] = summary["pattern_breakdown"].get(pattern, 0) + 1
        
        return summary

# Utility functions
async def scan_for_malware(scan_dir: Path) -> Tuple[List[Finding], Dict[str, Any], Dict[str, Any]]:
    """
    Convenience function to scan directory for malware
    
    Returns:
        Tuple of (findings, summary, wordpress_info)
    """
    scanner = MalwareScanner()
    findings = await scanner.scan_directory(scan_dir)
    summary = await scanner.get_malware_summary(findings)
    wp_info = scanner.detect_wordpress_info(scan_dir)
    
    return findings, summary, wp_info
